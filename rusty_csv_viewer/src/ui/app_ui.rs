use std::cell::RefCell;
use std::ops::Deref;
use std::rc::Rc;
use std::sync::{Arc, Mutex};

use crate::NativeUiEx;
use crate::ui::{AppState, ComponentParams, MainWindow};

/// Application object and data structure
pub struct MainWindowUi {
    /// Contains the Application and its components
    inner: Rc<RefCell<MainWindow>>,
    /// Contains mutable state
    state: Arc<Mutex<AppState>>,
    /// Default event handler that applies to the main window and all its children
    default_handler: RefCell<Option<nwg::EventHandler>>,
    /// User specified event handlers for common controls
    control_handlers: RefCell<Vec<nwg::EventHandler>>,
}

impl NativeUiEx<MainWindowUi, Arc<Mutex<AppState>>> for MainWindow {
    fn build_ui(mut data: MainWindow, state: Arc<Mutex<AppState>>) -> Result<MainWindowUi, nwg::NwgError> {
        use nwg::Event as E;

        let ui = MainWindowUi {
            inner: Rc::new(RefCell::new(data)),
            state: Arc::clone(&state),
            default_handler: Default::default(),
            control_handlers: Default::default(),
        };

        // Build all the static UI components
        //
        // Create the main window
        MainWindow::create_main_window(Rc::clone(&ui.inner), Arc::clone(&state))?;
        // Create the menubar and submenus
        MainWindow::create_menus(Rc::clone(&ui.inner))?;
        // Create the status bar
        MainWindow::create_status_bar(Rc::clone(&ui.inner))?;
        // Create the file picker dialog
        MainWindow::create_file_picker_dialog(Rc::clone(&ui.inner))?;

        // Weak references for the event handler closure
        let evt_ui = Rc::downgrade(&ui.inner);
        let evt_state = Arc::downgrade(&ui.state);

        // Default event handling closure
        let handle_events = move |evt, evt_data, handle| {
            // Try to upgrade the weak references into strong references
            // Should only fail if the event_handler outlives the data
            if let Some(ui) = evt_ui.upgrade() {
                if let Some(state) = evt_state.upgrade() {
                    match evt {
                        // WM_CLOSE message
                        E::OnWindowClose => {
                            if &handle == &ui.borrow().window.handle {
                                MainWindow::exit(&ui.borrow(), &mut state.lock().unwrap());
                            }
                        },
                        // WM_COMMAND message generated by nwg::MenuItem
                        // Handle should be a HMENU since MenuItems are the only component to handle this
                        E::OnMenuItemSelected => {
                            if let Some(menu) = MainWindow::find_menu_by_handle(&ui.borrow().menu, &handle) {
                                // Build the parameters for the command to be executed
                                let params =
                                    ComponentParams::new(Rc::clone(&ui), Arc::clone(&state),
                                                         evt, evt_data);
                                // Execute the command
                                menu.run(params)
                                    .map_err(|e| nwg::error_message(menu.name(), &format!("{:?}", e)));
                            }
                        }
                        _ => {}
                    }
                }
            }
        };

        // Bind the default event handler
        *ui.default_handler.borrow_mut() =
            Some(nwg::full_bind_event_handler(&ui.window.handle, handle_events));

        Ok(ui)
    }
}

impl Drop for MainWindowUi {
    fn drop(&mut self) {
        // To make sure that everything is freed without issues, the default handler must be unbound.
        let handler = self.default_handler.borrow();
        if handler.is_some() {
            nwg::unbind_event_handler(handler.as_ref().unwrap());
        }

        // Unbind any event handlers for common controls
        for h in self.control_handlers.borrow().iter() {
            nwg::unbind_event_handler(h);
        }
    }
}

impl Deref for MainWindowUi {
    type Target = MainWindow;

    fn deref(&self) -> &MainWindow {
        unsafe {
            &self.inner.as_ptr().as_ref().unwrap()
        }
    }
}